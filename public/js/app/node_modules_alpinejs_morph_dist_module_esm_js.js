"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk"] = self["webpackChunk"] || []).push([["node_modules_alpinejs_morph_dist_module_esm_js"],{

/***/ "./node_modules/@alpinejs/morph/dist/module.esm.js":
/*!*********************************************************!*\
  !*** ./node_modules/@alpinejs/morph/dist/module.esm.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ module_default),\n/* harmony export */   \"morph\": () => (/* binding */ morph)\n/* harmony export */ });\n// packages/morph/src/morph.js\nvar resolveStep = () => {\n};\nvar logger = () => {\n};\nfunction breakpoint(message) {\n  if (!debug)\n    return;\n  message && logger(message.replace(\"\\n\", \"\\\\n\"));\n  return new Promise((resolve) => resolveStep = () => resolve());\n}\nasync function morph(from, toHtml, options) {\n  assignOptions(options);\n  let toEl = createElement(toHtml);\n  if (window.Alpine && !from._x_dataStack) {\n    toEl._x_dataStack = window.Alpine.closestDataStack(from);\n    toEl._x_dataStack && window.Alpine.clone(from, toEl);\n  }\n  await breakpoint();\n  patch(from, toEl);\n  return from;\n}\nmorph.step = () => resolveStep();\nmorph.log = (theLogger) => {\n  logger = theLogger;\n};\nvar key;\nvar lookahead;\nvar updating;\nvar updated;\nvar removing;\nvar removed;\nvar adding;\nvar added;\nvar debug;\nvar noop = () => {\n};\nfunction assignOptions(options = {}) {\n  let defaultGetKey = (el) => el.getAttribute(\"key\");\n  updating = options.updating || noop;\n  updated = options.updated || noop;\n  removing = options.removing || noop;\n  removed = options.removed || noop;\n  adding = options.adding || noop;\n  added = options.added || noop;\n  key = options.key || defaultGetKey;\n  lookahead = options.lookahead || true;\n  debug = options.debug || false;\n}\nfunction createElement(html) {\n  return document.createRange().createContextualFragment(html).firstElementChild;\n}\nasync function patch(from, to) {\n  if (differentElementNamesTypesOrKeys(from, to)) {\n    let result = patchElement(from, to);\n    await breakpoint(\"Swap elements\");\n    return result;\n  }\n  let updateChildrenOnly = false;\n  if (shouldSkip(updating, from, to, () => updateChildrenOnly = true))\n    return;\n  window.Alpine && initializeAlpineOnTo(from, to, () => updateChildrenOnly = true);\n  if (textOrComment(to)) {\n    await patchNodeValue(from, to);\n    updated(from, to);\n    return;\n  }\n  if (!updateChildrenOnly) {\n    await patchAttributes(from, to);\n  }\n  updated(from, to);\n  await patchChildren(from, to);\n}\nfunction differentElementNamesTypesOrKeys(from, to) {\n  return from.nodeType != to.nodeType || from.nodeName != to.nodeName || getKey(from) != getKey(to);\n}\nfunction textOrComment(el) {\n  return el.nodeType === 3 || el.nodeType === 8;\n}\nfunction patchElement(from, to) {\n  if (shouldSkip(removing, from))\n    return;\n  let toCloned = to.cloneNode(true);\n  if (shouldSkip(adding, toCloned))\n    return;\n  dom(from).replace(toCloned);\n  removed(from);\n  added(toCloned);\n}\nasync function patchNodeValue(from, to) {\n  let value = to.nodeValue;\n  if (from.nodeValue !== value) {\n    from.nodeValue = value;\n    await breakpoint(\"Change text node to: \" + value);\n  }\n}\nasync function patchAttributes(from, to) {\n  if (from._x_isShown && !to._x_isShown) {\n    return;\n  }\n  if (!from._x_isShown && to._x_isShown) {\n    return;\n  }\n  let domAttributes = Array.from(from.attributes);\n  let toAttributes = Array.from(to.attributes);\n  for (let i = domAttributes.length - 1; i >= 0; i--) {\n    let name = domAttributes[i].name;\n    if (!to.hasAttribute(name)) {\n      from.removeAttribute(name);\n      await breakpoint(\"Remove attribute\");\n    }\n  }\n  for (let i = toAttributes.length - 1; i >= 0; i--) {\n    let name = toAttributes[i].name;\n    let value = toAttributes[i].value;\n    if (from.getAttribute(name) !== value) {\n      from.setAttribute(name, value);\n      await breakpoint(`Set [${name}] attribute to: \"${value}\"`);\n    }\n  }\n}\nasync function patchChildren(from, to) {\n  let domChildren = from.childNodes;\n  let toChildren = to.childNodes;\n  let toKeyToNodeMap = keyToMap(toChildren);\n  let domKeyDomNodeMap = keyToMap(domChildren);\n  let currentTo = dom(to).nodes().first();\n  let currentFrom = dom(from).nodes().first();\n  let domKeyHoldovers = {};\n  while (currentTo) {\n    let toKey = getKey(currentTo);\n    let domKey = getKey(currentFrom);\n    if (!currentFrom) {\n      if (toKey && domKeyHoldovers[toKey]) {\n        let holdover = domKeyHoldovers[toKey];\n        dom.append(from, holdover);\n        currentFrom = holdover;\n        await breakpoint(\"Add element (from key)\");\n      } else {\n        let added2 = addNodeTo(currentTo, from);\n        await breakpoint(\"Add element: \" + added2.outerHTML || 0);\n        currentTo = dom(currentTo).nodes().next();\n        continue;\n      }\n    }\n    if (lookahead) {\n      let nextToElementSibling = dom(currentTo).next();\n      if (nextToElementSibling && currentFrom.isEqualNode(nextToElementSibling)) {\n        currentFrom = addNodeBefore(currentTo, currentFrom);\n        domKey = getKey(currentFrom);\n        await breakpoint(\"Move element (lookahead)\");\n      }\n    }\n    if (toKey !== domKey) {\n      if (!toKey && domKey) {\n        domKeyHoldovers[domKey] = currentFrom;\n        currentFrom = addNodeBefore(currentTo, currentFrom);\n        domKeyHoldovers[domKey].remove();\n        currentFrom = dom(currentFrom).nodes.next();\n        currentTo = dom(currentTo).nodes.next();\n        await breakpoint('No \"to\" key');\n        continue;\n      }\n      if (toKey && !domKey) {\n        if (domKeyDomNodeMap[toKey]) {\n          currentFrom = dom(currentFrom).replace(domKeyDomNodeMap[toKey]);\n          await breakpoint('No \"from\" key');\n        }\n      }\n      if (toKey && domKey) {\n        domKeyHoldovers[domKey] = currentFrom;\n        let domKeyNode = domKeyDomNodeMap[toKey];\n        if (domKeyNode) {\n          currentFrom = dom(currentFrom).replace(domKeyNode);\n          await breakpoint('Move \"from\" key');\n        } else {\n          domKeyHoldovers[domKey] = currentFrom;\n          currentFrom = addNodeBefore(currentTo, currentFrom);\n          domKeyHoldovers[domKey].remove();\n          currentFrom = dom(currentFrom).next();\n          currentTo = dom(currentTo).next();\n          await breakpoint(\"I dont even know what this does\");\n          continue;\n        }\n      }\n    }\n    await patch(currentFrom, currentTo);\n    currentTo = currentTo && dom(currentTo).next();\n    currentFrom = currentFrom && dom(currentFrom).next();\n  }\n  while (currentFrom) {\n    if (!shouldSkip(removing, currentFrom)) {\n      let domForRemoval = currentFrom;\n      domForRemoval.remove();\n      await breakpoint(\"remove el\");\n      removed(domForRemoval);\n    }\n    currentFrom = dom(currentFrom).nodes().next();\n  }\n}\nfunction getKey(el) {\n  return el && el.nodeType === 1 && key(el);\n}\nfunction keyToMap(els) {\n  let map = {};\n  els.forEach((el) => {\n    let theKey = getKey(el);\n    if (theKey) {\n      map[theKey] = el;\n    }\n  });\n  return map;\n}\nfunction shouldSkip(hook, ...args) {\n  let skip = false;\n  hook(...args, () => skip = true);\n  return skip;\n}\nfunction addNodeTo(node, parent) {\n  if (!shouldSkip(adding, node)) {\n    let clone = node.cloneNode(true);\n    dom(parent).append(clone);\n    added(clone);\n    return clone;\n  }\n}\nfunction addNodeBefore(node, beforeMe) {\n  if (!shouldSkip(adding, node)) {\n    let clone = node.cloneNode(true);\n    dom(beforeMe).before(clone);\n    added(clone);\n    return clone;\n  }\n  return beforeMe;\n}\nfunction initializeAlpineOnTo(from, to, childrenOnly) {\n  if (from.nodeType !== 1)\n    return;\n  if (from._x_dataStack) {\n    window.Alpine.clone(from, to);\n  }\n}\nfunction dom(el) {\n  return new DomManager(el);\n}\nvar DomManager = class {\n  el = void 0;\n  constructor(el) {\n    this.el = el;\n  }\n  traversals = {\n    first: \"firstElementChild\",\n    next: \"nextElementSibling\",\n    parent: \"parentElement\"\n  };\n  nodes() {\n    this.traversals = {\n      first: \"firstChild\",\n      next: \"nextSibling\",\n      parent: \"parentNode\"\n    };\n    return this;\n  }\n  first() {\n    return this.teleportTo(this.el[this.traversals[\"first\"]]);\n  }\n  next() {\n    return this.teleportTo(this.teleportBack(this.el[this.traversals[\"next\"]]));\n  }\n  before(insertee) {\n    this.el[this.traversals[\"parent\"]].insertBefore(insertee, this.el);\n    return insertee;\n  }\n  replace(replacement) {\n    this.el[this.traversals[\"parent\"]].replaceChild(replacement, this.el);\n    return replacement;\n  }\n  append(appendee) {\n    this.el.appendChild(appendee);\n    return appendee;\n  }\n  teleportTo(el) {\n    if (!el)\n      return el;\n    if (el._x_teleport)\n      return el._x_teleport;\n    return el;\n  }\n  teleportBack(el) {\n    if (!el)\n      return el;\n    if (el._x_teleportBack)\n      return el._x_teleportBack;\n    return el;\n  }\n};\n\n// packages/morph/src/index.js\nfunction src_default(Alpine) {\n  Alpine.morph = morph;\n}\n\n// packages/morph/builds/module.js\nvar module_default = src_default;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGFscGluZWpzL21vcnBoL2Rpc3QvbW9kdWxlLmVzbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsS0FBSyxtQkFBbUIsTUFBTTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsK0RBQStELENBQWdCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFJRSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYWxwaW5lanMvbW9ycGgvZGlzdC9tb2R1bGUuZXNtLmpzPzliNTAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcGFja2FnZXMvbW9ycGgvc3JjL21vcnBoLmpzXG52YXIgcmVzb2x2ZVN0ZXAgPSAoKSA9PiB7XG59O1xudmFyIGxvZ2dlciA9ICgpID0+IHtcbn07XG5mdW5jdGlvbiBicmVha3BvaW50KG1lc3NhZ2UpIHtcbiAgaWYgKCFkZWJ1ZylcbiAgICByZXR1cm47XG4gIG1lc3NhZ2UgJiYgbG9nZ2VyKG1lc3NhZ2UucmVwbGFjZShcIlxcblwiLCBcIlxcXFxuXCIpKTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiByZXNvbHZlU3RlcCA9ICgpID0+IHJlc29sdmUoKSk7XG59XG5hc3luYyBmdW5jdGlvbiBtb3JwaChmcm9tLCB0b0h0bWwsIG9wdGlvbnMpIHtcbiAgYXNzaWduT3B0aW9ucyhvcHRpb25zKTtcbiAgbGV0IHRvRWwgPSBjcmVhdGVFbGVtZW50KHRvSHRtbCk7XG4gIGlmICh3aW5kb3cuQWxwaW5lICYmICFmcm9tLl94X2RhdGFTdGFjaykge1xuICAgIHRvRWwuX3hfZGF0YVN0YWNrID0gd2luZG93LkFscGluZS5jbG9zZXN0RGF0YVN0YWNrKGZyb20pO1xuICAgIHRvRWwuX3hfZGF0YVN0YWNrICYmIHdpbmRvdy5BbHBpbmUuY2xvbmUoZnJvbSwgdG9FbCk7XG4gIH1cbiAgYXdhaXQgYnJlYWtwb2ludCgpO1xuICBwYXRjaChmcm9tLCB0b0VsKTtcbiAgcmV0dXJuIGZyb207XG59XG5tb3JwaC5zdGVwID0gKCkgPT4gcmVzb2x2ZVN0ZXAoKTtcbm1vcnBoLmxvZyA9ICh0aGVMb2dnZXIpID0+IHtcbiAgbG9nZ2VyID0gdGhlTG9nZ2VyO1xufTtcbnZhciBrZXk7XG52YXIgbG9va2FoZWFkO1xudmFyIHVwZGF0aW5nO1xudmFyIHVwZGF0ZWQ7XG52YXIgcmVtb3Zpbmc7XG52YXIgcmVtb3ZlZDtcbnZhciBhZGRpbmc7XG52YXIgYWRkZWQ7XG52YXIgZGVidWc7XG52YXIgbm9vcCA9ICgpID0+IHtcbn07XG5mdW5jdGlvbiBhc3NpZ25PcHRpb25zKG9wdGlvbnMgPSB7fSkge1xuICBsZXQgZGVmYXVsdEdldEtleSA9IChlbCkgPT4gZWwuZ2V0QXR0cmlidXRlKFwia2V5XCIpO1xuICB1cGRhdGluZyA9IG9wdGlvbnMudXBkYXRpbmcgfHwgbm9vcDtcbiAgdXBkYXRlZCA9IG9wdGlvbnMudXBkYXRlZCB8fCBub29wO1xuICByZW1vdmluZyA9IG9wdGlvbnMucmVtb3ZpbmcgfHwgbm9vcDtcbiAgcmVtb3ZlZCA9IG9wdGlvbnMucmVtb3ZlZCB8fCBub29wO1xuICBhZGRpbmcgPSBvcHRpb25zLmFkZGluZyB8fCBub29wO1xuICBhZGRlZCA9IG9wdGlvbnMuYWRkZWQgfHwgbm9vcDtcbiAga2V5ID0gb3B0aW9ucy5rZXkgfHwgZGVmYXVsdEdldEtleTtcbiAgbG9va2FoZWFkID0gb3B0aW9ucy5sb29rYWhlYWQgfHwgdHJ1ZTtcbiAgZGVidWcgPSBvcHRpb25zLmRlYnVnIHx8IGZhbHNlO1xufVxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudChodG1sKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVSYW5nZSgpLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudChodG1sKS5maXJzdEVsZW1lbnRDaGlsZDtcbn1cbmFzeW5jIGZ1bmN0aW9uIHBhdGNoKGZyb20sIHRvKSB7XG4gIGlmIChkaWZmZXJlbnRFbGVtZW50TmFtZXNUeXBlc09yS2V5cyhmcm9tLCB0bykpIHtcbiAgICBsZXQgcmVzdWx0ID0gcGF0Y2hFbGVtZW50KGZyb20sIHRvKTtcbiAgICBhd2FpdCBicmVha3BvaW50KFwiU3dhcCBlbGVtZW50c1wiKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGxldCB1cGRhdGVDaGlsZHJlbk9ubHkgPSBmYWxzZTtcbiAgaWYgKHNob3VsZFNraXAodXBkYXRpbmcsIGZyb20sIHRvLCAoKSA9PiB1cGRhdGVDaGlsZHJlbk9ubHkgPSB0cnVlKSlcbiAgICByZXR1cm47XG4gIHdpbmRvdy5BbHBpbmUgJiYgaW5pdGlhbGl6ZUFscGluZU9uVG8oZnJvbSwgdG8sICgpID0+IHVwZGF0ZUNoaWxkcmVuT25seSA9IHRydWUpO1xuICBpZiAodGV4dE9yQ29tbWVudCh0bykpIHtcbiAgICBhd2FpdCBwYXRjaE5vZGVWYWx1ZShmcm9tLCB0byk7XG4gICAgdXBkYXRlZChmcm9tLCB0byk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghdXBkYXRlQ2hpbGRyZW5Pbmx5KSB7XG4gICAgYXdhaXQgcGF0Y2hBdHRyaWJ1dGVzKGZyb20sIHRvKTtcbiAgfVxuICB1cGRhdGVkKGZyb20sIHRvKTtcbiAgYXdhaXQgcGF0Y2hDaGlsZHJlbihmcm9tLCB0byk7XG59XG5mdW5jdGlvbiBkaWZmZXJlbnRFbGVtZW50TmFtZXNUeXBlc09yS2V5cyhmcm9tLCB0bykge1xuICByZXR1cm4gZnJvbS5ub2RlVHlwZSAhPSB0by5ub2RlVHlwZSB8fCBmcm9tLm5vZGVOYW1lICE9IHRvLm5vZGVOYW1lIHx8IGdldEtleShmcm9tKSAhPSBnZXRLZXkodG8pO1xufVxuZnVuY3Rpb24gdGV4dE9yQ29tbWVudChlbCkge1xuICByZXR1cm4gZWwubm9kZVR5cGUgPT09IDMgfHwgZWwubm9kZVR5cGUgPT09IDg7XG59XG5mdW5jdGlvbiBwYXRjaEVsZW1lbnQoZnJvbSwgdG8pIHtcbiAgaWYgKHNob3VsZFNraXAocmVtb3ZpbmcsIGZyb20pKVxuICAgIHJldHVybjtcbiAgbGV0IHRvQ2xvbmVkID0gdG8uY2xvbmVOb2RlKHRydWUpO1xuICBpZiAoc2hvdWxkU2tpcChhZGRpbmcsIHRvQ2xvbmVkKSlcbiAgICByZXR1cm47XG4gIGRvbShmcm9tKS5yZXBsYWNlKHRvQ2xvbmVkKTtcbiAgcmVtb3ZlZChmcm9tKTtcbiAgYWRkZWQodG9DbG9uZWQpO1xufVxuYXN5bmMgZnVuY3Rpb24gcGF0Y2hOb2RlVmFsdWUoZnJvbSwgdG8pIHtcbiAgbGV0IHZhbHVlID0gdG8ubm9kZVZhbHVlO1xuICBpZiAoZnJvbS5ub2RlVmFsdWUgIT09IHZhbHVlKSB7XG4gICAgZnJvbS5ub2RlVmFsdWUgPSB2YWx1ZTtcbiAgICBhd2FpdCBicmVha3BvaW50KFwiQ2hhbmdlIHRleHQgbm9kZSB0bzogXCIgKyB2YWx1ZSk7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHBhdGNoQXR0cmlidXRlcyhmcm9tLCB0bykge1xuICBpZiAoZnJvbS5feF9pc1Nob3duICYmICF0by5feF9pc1Nob3duKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghZnJvbS5feF9pc1Nob3duICYmIHRvLl94X2lzU2hvd24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IGRvbUF0dHJpYnV0ZXMgPSBBcnJheS5mcm9tKGZyb20uYXR0cmlidXRlcyk7XG4gIGxldCB0b0F0dHJpYnV0ZXMgPSBBcnJheS5mcm9tKHRvLmF0dHJpYnV0ZXMpO1xuICBmb3IgKGxldCBpID0gZG9tQXR0cmlidXRlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGxldCBuYW1lID0gZG9tQXR0cmlidXRlc1tpXS5uYW1lO1xuICAgIGlmICghdG8uaGFzQXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICBmcm9tLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIGF3YWl0IGJyZWFrcG9pbnQoXCJSZW1vdmUgYXR0cmlidXRlXCIpO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gdG9BdHRyaWJ1dGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGV0IG5hbWUgPSB0b0F0dHJpYnV0ZXNbaV0ubmFtZTtcbiAgICBsZXQgdmFsdWUgPSB0b0F0dHJpYnV0ZXNbaV0udmFsdWU7XG4gICAgaWYgKGZyb20uZ2V0QXR0cmlidXRlKG5hbWUpICE9PSB2YWx1ZSkge1xuICAgICAgZnJvbS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgICAgYXdhaXQgYnJlYWtwb2ludChgU2V0IFske25hbWV9XSBhdHRyaWJ1dGUgdG86IFwiJHt2YWx1ZX1cImApO1xuICAgIH1cbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gcGF0Y2hDaGlsZHJlbihmcm9tLCB0bykge1xuICBsZXQgZG9tQ2hpbGRyZW4gPSBmcm9tLmNoaWxkTm9kZXM7XG4gIGxldCB0b0NoaWxkcmVuID0gdG8uY2hpbGROb2RlcztcbiAgbGV0IHRvS2V5VG9Ob2RlTWFwID0ga2V5VG9NYXAodG9DaGlsZHJlbik7XG4gIGxldCBkb21LZXlEb21Ob2RlTWFwID0ga2V5VG9NYXAoZG9tQ2hpbGRyZW4pO1xuICBsZXQgY3VycmVudFRvID0gZG9tKHRvKS5ub2RlcygpLmZpcnN0KCk7XG4gIGxldCBjdXJyZW50RnJvbSA9IGRvbShmcm9tKS5ub2RlcygpLmZpcnN0KCk7XG4gIGxldCBkb21LZXlIb2xkb3ZlcnMgPSB7fTtcbiAgd2hpbGUgKGN1cnJlbnRUbykge1xuICAgIGxldCB0b0tleSA9IGdldEtleShjdXJyZW50VG8pO1xuICAgIGxldCBkb21LZXkgPSBnZXRLZXkoY3VycmVudEZyb20pO1xuICAgIGlmICghY3VycmVudEZyb20pIHtcbiAgICAgIGlmICh0b0tleSAmJiBkb21LZXlIb2xkb3ZlcnNbdG9LZXldKSB7XG4gICAgICAgIGxldCBob2xkb3ZlciA9IGRvbUtleUhvbGRvdmVyc1t0b0tleV07XG4gICAgICAgIGRvbS5hcHBlbmQoZnJvbSwgaG9sZG92ZXIpO1xuICAgICAgICBjdXJyZW50RnJvbSA9IGhvbGRvdmVyO1xuICAgICAgICBhd2FpdCBicmVha3BvaW50KFwiQWRkIGVsZW1lbnQgKGZyb20ga2V5KVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBhZGRlZDIgPSBhZGROb2RlVG8oY3VycmVudFRvLCBmcm9tKTtcbiAgICAgICAgYXdhaXQgYnJlYWtwb2ludChcIkFkZCBlbGVtZW50OiBcIiArIGFkZGVkMi5vdXRlckhUTUwgfHwgYWRkZWQyLm5vZGVWYWx1ZSk7XG4gICAgICAgIGN1cnJlbnRUbyA9IGRvbShjdXJyZW50VG8pLm5vZGVzKCkubmV4dCgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxvb2thaGVhZCkge1xuICAgICAgbGV0IG5leHRUb0VsZW1lbnRTaWJsaW5nID0gZG9tKGN1cnJlbnRUbykubmV4dCgpO1xuICAgICAgaWYgKG5leHRUb0VsZW1lbnRTaWJsaW5nICYmIGN1cnJlbnRGcm9tLmlzRXF1YWxOb2RlKG5leHRUb0VsZW1lbnRTaWJsaW5nKSkge1xuICAgICAgICBjdXJyZW50RnJvbSA9IGFkZE5vZGVCZWZvcmUoY3VycmVudFRvLCBjdXJyZW50RnJvbSk7XG4gICAgICAgIGRvbUtleSA9IGdldEtleShjdXJyZW50RnJvbSk7XG4gICAgICAgIGF3YWl0IGJyZWFrcG9pbnQoXCJNb3ZlIGVsZW1lbnQgKGxvb2thaGVhZClcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0b0tleSAhPT0gZG9tS2V5KSB7XG4gICAgICBpZiAoIXRvS2V5ICYmIGRvbUtleSkge1xuICAgICAgICBkb21LZXlIb2xkb3ZlcnNbZG9tS2V5XSA9IGN1cnJlbnRGcm9tO1xuICAgICAgICBjdXJyZW50RnJvbSA9IGFkZE5vZGVCZWZvcmUoY3VycmVudFRvLCBjdXJyZW50RnJvbSk7XG4gICAgICAgIGRvbUtleUhvbGRvdmVyc1tkb21LZXldLnJlbW92ZSgpO1xuICAgICAgICBjdXJyZW50RnJvbSA9IGRvbShjdXJyZW50RnJvbSkubm9kZXMubmV4dCgpO1xuICAgICAgICBjdXJyZW50VG8gPSBkb20oY3VycmVudFRvKS5ub2Rlcy5uZXh0KCk7XG4gICAgICAgIGF3YWl0IGJyZWFrcG9pbnQoJ05vIFwidG9cIiBrZXknKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodG9LZXkgJiYgIWRvbUtleSkge1xuICAgICAgICBpZiAoZG9tS2V5RG9tTm9kZU1hcFt0b0tleV0pIHtcbiAgICAgICAgICBjdXJyZW50RnJvbSA9IGRvbShjdXJyZW50RnJvbSkucmVwbGFjZShkb21LZXlEb21Ob2RlTWFwW3RvS2V5XSk7XG4gICAgICAgICAgYXdhaXQgYnJlYWtwb2ludCgnTm8gXCJmcm9tXCIga2V5Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0b0tleSAmJiBkb21LZXkpIHtcbiAgICAgICAgZG9tS2V5SG9sZG92ZXJzW2RvbUtleV0gPSBjdXJyZW50RnJvbTtcbiAgICAgICAgbGV0IGRvbUtleU5vZGUgPSBkb21LZXlEb21Ob2RlTWFwW3RvS2V5XTtcbiAgICAgICAgaWYgKGRvbUtleU5vZGUpIHtcbiAgICAgICAgICBjdXJyZW50RnJvbSA9IGRvbShjdXJyZW50RnJvbSkucmVwbGFjZShkb21LZXlOb2RlKTtcbiAgICAgICAgICBhd2FpdCBicmVha3BvaW50KCdNb3ZlIFwiZnJvbVwiIGtleScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvbUtleUhvbGRvdmVyc1tkb21LZXldID0gY3VycmVudEZyb207XG4gICAgICAgICAgY3VycmVudEZyb20gPSBhZGROb2RlQmVmb3JlKGN1cnJlbnRUbywgY3VycmVudEZyb20pO1xuICAgICAgICAgIGRvbUtleUhvbGRvdmVyc1tkb21LZXldLnJlbW92ZSgpO1xuICAgICAgICAgIGN1cnJlbnRGcm9tID0gZG9tKGN1cnJlbnRGcm9tKS5uZXh0KCk7XG4gICAgICAgICAgY3VycmVudFRvID0gZG9tKGN1cnJlbnRUbykubmV4dCgpO1xuICAgICAgICAgIGF3YWl0IGJyZWFrcG9pbnQoXCJJIGRvbnQgZXZlbiBrbm93IHdoYXQgdGhpcyBkb2VzXCIpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGF3YWl0IHBhdGNoKGN1cnJlbnRGcm9tLCBjdXJyZW50VG8pO1xuICAgIGN1cnJlbnRUbyA9IGN1cnJlbnRUbyAmJiBkb20oY3VycmVudFRvKS5uZXh0KCk7XG4gICAgY3VycmVudEZyb20gPSBjdXJyZW50RnJvbSAmJiBkb20oY3VycmVudEZyb20pLm5leHQoKTtcbiAgfVxuICB3aGlsZSAoY3VycmVudEZyb20pIHtcbiAgICBpZiAoIXNob3VsZFNraXAocmVtb3ZpbmcsIGN1cnJlbnRGcm9tKSkge1xuICAgICAgbGV0IGRvbUZvclJlbW92YWwgPSBjdXJyZW50RnJvbTtcbiAgICAgIGRvbUZvclJlbW92YWwucmVtb3ZlKCk7XG4gICAgICBhd2FpdCBicmVha3BvaW50KFwicmVtb3ZlIGVsXCIpO1xuICAgICAgcmVtb3ZlZChkb21Gb3JSZW1vdmFsKTtcbiAgICB9XG4gICAgY3VycmVudEZyb20gPSBkb20oY3VycmVudEZyb20pLm5vZGVzKCkubmV4dCgpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRLZXkoZWwpIHtcbiAgcmV0dXJuIGVsICYmIGVsLm5vZGVUeXBlID09PSAxICYmIGtleShlbCk7XG59XG5mdW5jdGlvbiBrZXlUb01hcChlbHMpIHtcbiAgbGV0IG1hcCA9IHt9O1xuICBlbHMuZm9yRWFjaCgoZWwpID0+IHtcbiAgICBsZXQgdGhlS2V5ID0gZ2V0S2V5KGVsKTtcbiAgICBpZiAodGhlS2V5KSB7XG4gICAgICBtYXBbdGhlS2V5XSA9IGVsO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBtYXA7XG59XG5mdW5jdGlvbiBzaG91bGRTa2lwKGhvb2ssIC4uLmFyZ3MpIHtcbiAgbGV0IHNraXAgPSBmYWxzZTtcbiAgaG9vayguLi5hcmdzLCAoKSA9PiBza2lwID0gdHJ1ZSk7XG4gIHJldHVybiBza2lwO1xufVxuZnVuY3Rpb24gYWRkTm9kZVRvKG5vZGUsIHBhcmVudCkge1xuICBpZiAoIXNob3VsZFNraXAoYWRkaW5nLCBub2RlKSkge1xuICAgIGxldCBjbG9uZSA9IG5vZGUuY2xvbmVOb2RlKHRydWUpO1xuICAgIGRvbShwYXJlbnQpLmFwcGVuZChjbG9uZSk7XG4gICAgYWRkZWQoY2xvbmUpO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxufVxuZnVuY3Rpb24gYWRkTm9kZUJlZm9yZShub2RlLCBiZWZvcmVNZSkge1xuICBpZiAoIXNob3VsZFNraXAoYWRkaW5nLCBub2RlKSkge1xuICAgIGxldCBjbG9uZSA9IG5vZGUuY2xvbmVOb2RlKHRydWUpO1xuICAgIGRvbShiZWZvcmVNZSkuYmVmb3JlKGNsb25lKTtcbiAgICBhZGRlZChjbG9uZSk7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG4gIHJldHVybiBiZWZvcmVNZTtcbn1cbmZ1bmN0aW9uIGluaXRpYWxpemVBbHBpbmVPblRvKGZyb20sIHRvLCBjaGlsZHJlbk9ubHkpIHtcbiAgaWYgKGZyb20ubm9kZVR5cGUgIT09IDEpXG4gICAgcmV0dXJuO1xuICBpZiAoZnJvbS5feF9kYXRhU3RhY2spIHtcbiAgICB3aW5kb3cuQWxwaW5lLmNsb25lKGZyb20sIHRvKTtcbiAgfVxufVxuZnVuY3Rpb24gZG9tKGVsKSB7XG4gIHJldHVybiBuZXcgRG9tTWFuYWdlcihlbCk7XG59XG52YXIgRG9tTWFuYWdlciA9IGNsYXNzIHtcbiAgZWwgPSB2b2lkIDA7XG4gIGNvbnN0cnVjdG9yKGVsKSB7XG4gICAgdGhpcy5lbCA9IGVsO1xuICB9XG4gIHRyYXZlcnNhbHMgPSB7XG4gICAgZmlyc3Q6IFwiZmlyc3RFbGVtZW50Q2hpbGRcIixcbiAgICBuZXh0OiBcIm5leHRFbGVtZW50U2libGluZ1wiLFxuICAgIHBhcmVudDogXCJwYXJlbnRFbGVtZW50XCJcbiAgfTtcbiAgbm9kZXMoKSB7XG4gICAgdGhpcy50cmF2ZXJzYWxzID0ge1xuICAgICAgZmlyc3Q6IFwiZmlyc3RDaGlsZFwiLFxuICAgICAgbmV4dDogXCJuZXh0U2libGluZ1wiLFxuICAgICAgcGFyZW50OiBcInBhcmVudE5vZGVcIlxuICAgIH07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZmlyc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMudGVsZXBvcnRUbyh0aGlzLmVsW3RoaXMudHJhdmVyc2Fsc1tcImZpcnN0XCJdXSk7XG4gIH1cbiAgbmV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy50ZWxlcG9ydFRvKHRoaXMudGVsZXBvcnRCYWNrKHRoaXMuZWxbdGhpcy50cmF2ZXJzYWxzW1wibmV4dFwiXV0pKTtcbiAgfVxuICBiZWZvcmUoaW5zZXJ0ZWUpIHtcbiAgICB0aGlzLmVsW3RoaXMudHJhdmVyc2Fsc1tcInBhcmVudFwiXV0uaW5zZXJ0QmVmb3JlKGluc2VydGVlLCB0aGlzLmVsKTtcbiAgICByZXR1cm4gaW5zZXJ0ZWU7XG4gIH1cbiAgcmVwbGFjZShyZXBsYWNlbWVudCkge1xuICAgIHRoaXMuZWxbdGhpcy50cmF2ZXJzYWxzW1wicGFyZW50XCJdXS5yZXBsYWNlQ2hpbGQocmVwbGFjZW1lbnQsIHRoaXMuZWwpO1xuICAgIHJldHVybiByZXBsYWNlbWVudDtcbiAgfVxuICBhcHBlbmQoYXBwZW5kZWUpIHtcbiAgICB0aGlzLmVsLmFwcGVuZENoaWxkKGFwcGVuZGVlKTtcbiAgICByZXR1cm4gYXBwZW5kZWU7XG4gIH1cbiAgdGVsZXBvcnRUbyhlbCkge1xuICAgIGlmICghZWwpXG4gICAgICByZXR1cm4gZWw7XG4gICAgaWYgKGVsLl94X3RlbGVwb3J0KVxuICAgICAgcmV0dXJuIGVsLl94X3RlbGVwb3J0O1xuICAgIHJldHVybiBlbDtcbiAgfVxuICB0ZWxlcG9ydEJhY2soZWwpIHtcbiAgICBpZiAoIWVsKVxuICAgICAgcmV0dXJuIGVsO1xuICAgIGlmIChlbC5feF90ZWxlcG9ydEJhY2spXG4gICAgICByZXR1cm4gZWwuX3hfdGVsZXBvcnRCYWNrO1xuICAgIHJldHVybiBlbDtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvbW9ycGgvc3JjL2luZGV4LmpzXG5mdW5jdGlvbiBzcmNfZGVmYXVsdChBbHBpbmUpIHtcbiAgQWxwaW5lLm1vcnBoID0gbW9ycGg7XG59XG5cbi8vIHBhY2thZ2VzL21vcnBoL2J1aWxkcy9tb2R1bGUuanNcbnZhciBtb2R1bGVfZGVmYXVsdCA9IHNyY19kZWZhdWx0O1xuZXhwb3J0IHtcbiAgbW9kdWxlX2RlZmF1bHQgYXMgZGVmYXVsdCxcbiAgbW9ycGhcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@alpinejs/morph/dist/module.esm.js\n");

/***/ })

}]);